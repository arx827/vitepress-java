import{_ as e,c as a,o as d,a as c}from"./app.b24c6e2d.js";const p=JSON.parse('{"title":"第 1 章：概論","description":"","frontmatter":{"title":"第 1 章：概論"},"headers":[{"level":2,"title":"1-1 Java 是當前最紅程式語言","slug":"_1-1-java-是當前最紅程式語言","link":"#_1-1-java-是當前最紅程式語言","children":[]},{"level":2,"title":"1-2 Java 的歷史","slug":"_1-2-java-的歷史","link":"#_1-2-java-的歷史","children":[]},{"level":2,"title":"1-3 Java 的特色","slug":"_1-3-java-的特色","link":"#_1-3-java-的特色","children":[]}],"relativePath":"guide/zero/chapter_1.md"}'),i={name:"guide/zero/chapter_1.md"},o=c('<h1 id="第-1-章-概論" tabindex="-1">第 1 章：概論 <a class="header-anchor" href="#第-1-章-概論" aria-hidden="true">#</a></h1><h2 id="_1-1-java-是當前最紅程式語言" tabindex="-1">1-1 Java 是當前最紅程式語言 <a class="header-anchor" href="#_1-1-java-是當前最紅程式語言" aria-hidden="true">#</a></h2><p><a href="https://www.tiobe.com/tiobe-index" target="_blank" rel="noreferrer">TIOBE</a>，調查美國大企業使用程式語言的種類，2018年Java是排行第一名。</p><h2 id="_1-2-java-的歷史" tabindex="-1">1-2 Java 的歷史 <a class="header-anchor" href="#_1-2-java-的歷史" aria-hidden="true">#</a></h2><ul><li>1995 年 5 月，Java 語言誕生。</li><li>1996 年 1 月，第一個 JDK-JDK1.0 誕生。</li><li>1996 年 4 月，10 個最主要的作業系統供應商，申明將在其產品中嵌入 Java 技術。</li><li>1997 年 2 月，JDK1.1 釋出。</li><li>1998 年 12 月，Java2 企業平台 J2EE 釋出。</li><li>1999 年 6 月，SUN 公司釋出 Java 的三個版本：標準版(J2SE)、企業版(J2EE)和微型版(J2ME)。</li><li>2000 年 5 月，JDK1.3 釋出。</li><li>2000 年 5 月，JDK1.4 釋出。</li><li>2001 年 9 月，J2EE1.3 釋出。</li><li>2002 年 2 月，J2SE1.4 釋出，自此 Java 的計算能力有了大幅提升。</li><li>2004 年 9 月，J2SE1.5 釋出，成為 Java 語言發展史上的又一里程碑，為了表示該版本的重要性，J2SE1.5 更名為 Java SE 5.0。</li><li>2005 年 6 月，SUN 公司公開 Java SE 6。此時，Java 的各種版本已經更名，已取消其中的數字「 2 」：J2EE 更名為 Java EE (企業版)，J2SE 更名為 Java SE (標準版)，J2ME 更名為 Java ME (精簡版)。</li><li>2006 年 12 月，SUN 公司釋出 JRE6.0。</li><li>2009 年 12 月，SUN 公司釋出 Java EE 6。</li><li>2010 年 11 月，由於 Oracle 公司併購 Sun，所以 Java 技術的開發與推廣改由 Oracle (甲骨文) 公司接手。</li><li>2011 年 7 月，Oracle 公司發布 Java SE 7。</li><li>2014 年 3 月，Oracle 公司發布 Java SE 8。</li><li>2017 年 9 月，Oracle 公司發布 Java SE 9。</li><li>2018 年 3 月，Oracle 公司發布 Java SE 10。</li></ul><h2 id="_1-3-java-的特色" tabindex="-1">1-3 Java 的特色 <a class="header-anchor" href="#_1-3-java-的特色" aria-hidden="true">#</a></h2><p>根據昇陽公司當時的廣告，Java 的特色有：</p><ul><li><h3 id="簡單的-simple" tabindex="-1">簡單的 (Simple) <a class="header-anchor" href="#簡單的-simple" aria-hidden="true">#</a></h3><ul><li><code>Java</code> 號稱比 <code>C++</code> 簡單。</li><li><code>Java</code> 移除 <code>指標</code> 並用 <code>介面 (Interface)</code> 取代 <code>多重繼承</code>。</li><li><code>C++</code> 必須由程式設計者動態的分配與收集記憶體，但 <code>Java</code> 卻將記憶體回收與管理改為自動化。</li></ul></li><li><h3 id="物件導向的-object-oriented" tabindex="-1">物件導向的 (Object-Oriented) <a class="header-anchor" href="#物件導向的-object-oriented" aria-hidden="true">#</a></h3><ul><li><code>Java</code> 是 第一個以物件導向為基礎所開發的程式語言。(備注 <code>C++</code> 是繼承 C，再加上物件導向)。</li><li>完整的物件包含 <code>方法</code> 與 <code>屬性</code>。</li><li>物件導向裡，要先將所有方法，依照其功能分類，此稱為「 <code>類別</code> 」，此類別不僅有方法也有屬性。</li><li>類別可以創造出許許多多的「 <code>物件</code> 」。</li><li>物件導向的特性：<code>封裝</code>、<code>繼承</code>、<code>多形</code>。</li></ul></li><li><h3 id="分散式的-distributed" tabindex="-1">分散式的 (Distributed) <a class="header-anchor" href="#分散式的-distributed" aria-hidden="true">#</a></h3><ul><li>所謂的 <code>分散式系統</code> 是指，數台電腦藉由網路連結，而一起工作，並彼此分享資料。昇陽宣稱撰寫這些網路程式對 <code>Java</code> 而言，就如同將資料放入自己硬碟的檔案，或從自己硬碟檔案取出資料一樣簡單。</li></ul></li><li><h3 id="解譯式的-interpreted" tabindex="-1">解譯式的 (Interpreted) <a class="header-anchor" href="#解譯式的-interpreted" aria-hidden="true">#</a></h3><p><code>Java</code> 程式需要一個 <code>編譯程式</code> 將 <code>原始程式 (*.java)</code> 編譯為 <code>Java 虛擬機器碼 (Virtual Machine Code)</code>，此機器碼稱為 <code>Bytecode</code>。此種 <code>Bytecode</code> 與機器無關，只要此機器具有 <code>JRE (Java Runtime Environment)</code>，即能將 <code>Bytecode</code> 解譯成可執行的 <code>Java 虛擬機器碼</code>。也就是不同作業系統，會有其對應的 <code>JRE</code>，這樣使用者就不用理會程式要在哪種作業系統執行，可跨平台。</p></li><li><h3 id="穩健的-robust" tabindex="-1">穩健的 (Robust) <a class="header-anchor" href="#穩健的-robust" aria-hidden="true">#</a></h3><p>穩健的程式，象徵此程式值得信賴，有許多程式語言均在執行階段才發生錯誤，導致程式無預警結束。昇陽宣稱 <code>Java 編譯器</code> 在編譯階段費了很大的心思，希望找出任何可能的錯誤。其次，<code>Java</code> 也去掉指標型別，因為指標型別較易導致執行階段錯誤。</p><p><code>Java</code> 有一種<code>錯誤處理機制</code>，此種機制可以攔截使用者的操作錯誤，如輸入資料型別不符，或機器的例外處理，或磁碟機已滿等例外情況，而確保程式穩健地執行。</p></li><li><h3 id="安全的-secure" tabindex="-1">安全的 (Secure) <a class="header-anchor" href="#安全的-secure" aria-hidden="true">#</a></h3><p>當一支 <code>Java Applet</code> 被下載而執行的時候，<code>JVM (Java Virtual Machine)</code> 可以監視它的動作，比如說不可以讀或寫入使用者的硬碟，這樣使用者的硬碟才不會被惡意程式破壞或竊取，這更增添了網際網路程式執行的安全性。除此之外，還可以自行調整 <code>Java</code> 的安全性設定，這種做法比較有彈性。程式也可以由 <code>Java 認證</code>，取得一個安全的 <code>數位簽章</code>，以便告知使用者您的 Java 程式是無害的。</p></li><li><h3 id="結構中立的-architecture-neutral" tabindex="-1">結構中立的 (Architecture-Neutral) <a class="header-anchor" href="#結構中立的-architecture-neutral" aria-hidden="true">#</a></h3><p><code>Java</code> 最值得稱道的特性就是它是一種 <code>結構中立</code> 的語言，此又稱為 <code>與平台無關(platform-independent)</code> 的語言，只要你寫完程式，則該程式就可以在任何具有 <code>JRE</code> 的任意作業系統執行。</p></li><li><h3 id="可攜式的-portable" tabindex="-1">可攜式的 (Portable) <a class="header-anchor" href="#可攜式的-portable" aria-hidden="true">#</a></h3><p><code>Java</code> 程式是一種可攜式的程式，因為它的 <code>Bytecode</code> 並不用重新編譯即可在別台電腦執行，此外，它也不特別限定在何種平台執行。</p></li><li><h3 id="高效率的-performance" tabindex="-1">高效率的 (Performance) <a class="header-anchor" href="#高效率的-performance" aria-hidden="true">#</a></h3><p>以往 <code>Java</code> 的執行效率最為人所詬病，因為 <code>Java</code> 的 <code>Bytecode</code> 對 JRE 而言是解譯式的，所以 <code>Bytecode</code> 並不直接由系統所執行，而是由 <code>Java JRE</code> 解譯而執行，然而解譯器的效率對輸出入交錯的應用程式而言是足夠的。因為此種程式 <code>CPU</code> 通常閒置等待使用者的輸入或輸出資料。</p></li><li><h3 id="多執行緒的-multithreaded" tabindex="-1">多執行緒的 (Multithreaded) <a class="header-anchor" href="#多執行緒的-multithreaded" aria-hidden="true">#</a></h3><p><code>多執行緒</code> 是指一個城市具有同時執行多個工作的能力，多執行緒對 <code>Java</code> 而言是 <code>自動控制</code> 的。多執行緒對<code>圖形介面 (Graphic User Interface, GUI)</code> 及 <code>網路應用程式 (Network Programming)</code> 而言特別有用，於網路程式裡，一台伺服器必須同時服務或監控好幾台 <code>clients</code>，所以多執行緒已是程式語言的必備功能。</p></li><li><h3 id="動態的-dynamic" tabindex="-1">動態的 (Dynamic) <a class="header-anchor" href="#動態的-dynamic" aria-hidden="true">#</a></h3><p><code>Java</code> 是設計來適合會進化的環境，可以自由地在原類別中新增屬性或方法，而不影響舊有程式的進行。</p></li></ul>',8),r=[o];function l(t,h,n,J,v,s){return d(),a("div",null,r)}const _=e(i,[["render",l]]);export{p as __pageData,_ as default};
