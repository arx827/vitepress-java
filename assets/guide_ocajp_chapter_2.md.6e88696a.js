import{_ as a,c as e,o as i,a as d}from"./app.b24c6e2d.js";const _=JSON.parse('{"title":"2. Java程式語法簡介","description":"","frontmatter":{"title":"2. Java程式語法簡介"},"headers":[{"level":2,"title":"2.1 Java程式語言的特色","slug":"_2-1-java程式語言的特色","link":"#_2-1-java程式語言的特色","children":[]},{"level":2,"title":"2.2 Java的跨平台運行","slug":"_2-2-java的跨平台運行","link":"#_2-2-java的跨平台運行","children":[]},{"level":2,"title":"2.3 JDK、JRE 和 JVM 的差別","slug":"_2-3-jdk、jre-和-jvm-的差別","link":"#_2-3-jdk、jre-和-jvm-的差別","children":[]},{"level":2,"title":"2.4 Java 整合開發工具 (IDE) 介紹","slug":"_2-4-java-整合開發工具-ide-介紹","link":"#_2-4-java-整合開發工具-ide-介紹","children":[]}],"relativePath":"guide/ocajp/chapter_2.md"}'),r={name:"guide/ocajp/chapter_2.md"},l=d('<h1 id="_2-java程式語法簡介" tabindex="-1">2. Java程式語法簡介 <a class="header-anchor" href="#_2-java程式語法簡介" aria-hidden="true">#</a></h1><h2 id="_2-1-java程式語言的特色" tabindex="-1">2.1 Java程式語言的特色 <a class="header-anchor" href="#_2-1-java程式語言的特色" aria-hidden="true">#</a></h2><ul><li><h3 id="_1-跨平台" tabindex="-1">1. 跨平台 <a class="header-anchor" href="#_1-跨平台" aria-hidden="true">#</a></h3><p>Java 不只能在 Windows 上執行，還能在其他平台作業執行。</p></li><li><h3 id="_2-簡單" tabindex="-1">2. 簡單 <a class="header-anchor" href="#_2-簡單" aria-hidden="true">#</a></h3><p>開發 Java 程式比 C++ 簡單。Java 移除了複雜的指標使用，用介面代替多重繼承，而記憶體管理也改為自動管理，不需人為操作。</p></li><li><h3 id="_3-物件導向" tabindex="-1">3. 物件導向 <a class="header-anchor" href="#_3-物件導向" aria-hidden="true">#</a></h3><p>Java 是標準的物件導向程式語言，和 C++ 一樣擁有繼承、多型、封裝等3大特色。</p></li><li><h3 id="_4-安全" tabindex="-1">4. 安全 <a class="header-anchor" href="#_4-安全" aria-hidden="true">#</a></h3><p>Java 具有可以調整的安全性設定，也可以簽署數位簽名。</p></li><li><h3 id="_5-穩定的" tabindex="-1">5. 穩定的 <a class="header-anchor" href="#_5-穩定的" aria-hidden="true">#</a></h3><ul><li>Java 語言對型態的檢查十分地嚴格，是一個非常重視型別 (strong-type) 的程式語言，可以使用如列舉型別 (enum)、泛型 (generic) 等功能在程式編譯時即檢查出型態問題，避免可能發生的錯誤。</li><li>Java 語言不支援指標，可以避免因為記憶體控制不當所引起的問題；提供記憶體回收的功能，因此扣除程式對物件的不當使用，較不會有 OutOfMemory 的狀況。</li><li>Java 語言提供例外處理 (exception handling) 以防止程式因例外而異常終止。</li></ul></li><li><h3 id="_6-多執行緒" tabindex="-1">6. 多執行緒 <a class="header-anchor" href="#_6-多執行緒" aria-hidden="true">#</a></h3><p>Java 具備同時執行多項工作能力，例如可以同時網路下載影片和放映。對 Java 而言多執行緒是自動控制的。</p></li></ul><h2 id="_2-2-java的跨平台運行" tabindex="-1">2.2 Java的跨平台運行 <a class="header-anchor" href="#_2-2-java的跨平台運行" aria-hidden="true">#</a></h2><ul><li><h3 id="程式大略分為『系統程式』與『應用程式』。" tabindex="-1">程式大略分為『系統程式』與『應用程式』。 <a class="header-anchor" href="#程式大略分為『系統程式』與『應用程式』。" aria-hidden="true">#</a></h3><ul><li><h4 id="系統程式" tabindex="-1">系統程式 <a class="header-anchor" href="#系統程式" aria-hidden="true">#</a></h4><p>管理硬體資源，大多時候不是針對特定目的而撰寫。如 Windows、Mac、Linux 等。</p></li><li><h4 id="應用程式" tabindex="-1">應用程式 <a class="header-anchor" href="#應用程式" aria-hidden="true">#</a></h4><p>針對某些特定目的而撰寫，大多時候運行在系統程式之上。如 Java 程式、Office、Firefox 等。</p></li></ul></li><li><h3 id="程式語言可分成幾大類" tabindex="-1">程式語言可分成幾大類： <a class="header-anchor" href="#程式語言可分成幾大類" aria-hidden="true">#</a></h3><ul><li><h4 id="機器語言" tabindex="-1">機器語言 <a class="header-anchor" href="#機器語言" aria-hidden="true">#</a></h4><p>機器語言 (Machine Language) 是電腦可以直接執行的語言，它的語言指令是由一連串 0 與 1 所排列組合而成的。</p></li><li><h4 id="組合語言" tabindex="-1">組合語言 <a class="header-anchor" href="#組合語言" aria-hidden="true">#</a></h4><p>機器語言的指令是由 0 與 1 組成，對人類來講很難辨識。於是便將機器語言基本指令用符號來幫助人類記憶，這些符號就稱為記憶符號；所有的記憶符號就組成了組合語言 (Assembly Language)。組合語言是一種以符號來代替機器語言的程式語言，因此也是最接近機器語言的程式語言。</p></li><li><h4 id="高階語言" tabindex="-1">高階語言 <a class="header-anchor" href="#高階語言" aria-hidden="true">#</a></h4><p>具有機器無關 (machine independence) 的特性。在某一種電腦上所撰寫的高階語言程式，如果設計結構良好，通常不需要太多的修改就能挪到別種電腦上使用，這種特色又稱 跨平台(cross platform) 或 可攜性 (portability)。</p></li></ul></li></ul><p>電腦硬體真正可以看得懂的是<code>機器碼</code>，只有以機器碼撰寫的檔案才可以被電腦執行 (稱為 <code>執行檔</code>)，因此必須將程式設計師撰寫的程式碼透過一連串的流程轉變成執行檔。大體上透過兩種方式進行：</p><ul><li><h4 id="_1-編譯器" tabindex="-1">1. 編譯器 <a class="header-anchor" href="#_1-編譯器" aria-hidden="true">#</a></h4><code>編譯</code> 是先將程式全部翻譯成機器碼後，電腦一口氣執行這些機器碼；以後再執行程式，只要執行機器碼，不需要重新編譯。</li><li><h4 id="_2-直譯器" tabindex="-1">2. 直譯器 <a class="header-anchor" href="#_2-直譯器" aria-hidden="true">#</a></h4><code>直譯</code> 則是每翻譯完一段程式，電腦就執行一段機器碼，接著再繼續翻譯下一段，直到結束為止。每次電腦重新執行程式都要再經過直譯的過程。</li></ul><p>Java 不同於一般的編譯語言和直譯語言。它首先將原始碼 (Source Code) 編譯成位元組碼 (Byte Code)，副檔名為 *.class，然後依賴各種不同平台上的 「<code>Java虛擬機器 (Virtual Machine)：JVM</code>」來解釋執行該 *.class 檔案，從而實作了「<code>一次編寫，到處執行 (Write once, run anywhere)</code>」的跨平台特性。</p><h2 id="_2-3-jdk、jre-和-jvm-的差別" tabindex="-1">2.3 JDK、JRE 和 JVM 的差別 <a class="header-anchor" href="#_2-3-jdk、jre-和-jvm-的差別" aria-hidden="true">#</a></h2><ul><li>SDK (Software Development Kit，軟體開發工具包)：用於幫助開發人員提高工作效率。</li><li>JDK (Java Development Kit)：也稱 Java Software Development Kit，是 Java 開發工具包，主要用於構建在 Java 平台上執行的應用程式。可以到 Oracle 官網上選擇適合的作業系統進行<a href="https://www.oracle.com/tw/java/technologies/downloads/" target="_blank" rel="noreferrer">下載</a>、<a href="https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html" target="_blank" rel="noreferrer">Java SE8</a>。</li><li>JRE (Java Runtime Environment，Java執行環境)，也就是 Java 平台。所有的 Java 程式都要在 JRE 下才能執行。開發Java程式才需要JDK，如果只是要執行 Java 的程式或遊戲，只要裝 JRE 就可以了。</li></ul><table><tr><td rowspan="5" style="vertical-align:initial;width:100px;background:#152b24;">JDK</td><td colspan="2">程式語言主體 (Java Language)</td></tr><tr><td colspan="2">開發工具 (Tools &amp; Tool APIs)</td></tr><tr><td rowspan="3" style="vertical-align:middle;width:100px;background:#152b24;">JRE</td><td>部署技術 (Deployment)</td></tr><tr><td>Java SE API</td></tr><tr><td style="background:#152b24;">JVM</td></tr></table><h2 id="_2-4-java-整合開發工具-ide-介紹" tabindex="-1">2.4 Java 整合開發工具 (IDE) 介紹 <a class="header-anchor" href="#_2-4-java-整合開發工具-ide-介紹" aria-hidden="true">#</a></h2><p>比較常見的開發工具有：</p><ul><li><ol><li>Oracle 公司的 <code>NetBeans IDE</code></li></ol></li><li><ol start="2"><li>Oracle 公司的 <code>JDeveloper</code></li></ol></li><li><ol start="3"><li>IBM 公司的<code> Eclipse</code></li></ol></li><li><h3 id="_2-4-1-下載-eclipse-作為開發工具" tabindex="-1">2.4.1 下載 Eclipse 作為開發工具 <a class="header-anchor" href="#_2-4-1-下載-eclipse-作為開發工具" aria-hidden="true">#</a></h3><p><a href="http://www.eclipse.org/downloads/" target="_blank" rel="noreferrer">下載 Eclipse</a></p><p>可以選擇要下載「 <code>Java EE Developers 版</code> 」或是「 <code>Java Developers 版</code> 」的工具。後者指的就是「 <code>Java SE Developers 版</code> 」。 「 <code>Java EE Developers 版</code> 」好處是支援 <code>Java EE 規格</code>，所以可以開發如網站等 EE 範圍的 <code>Java</code> 程式；壞處是比較佔空間。</p><p>下載完成後，可移動到欲放置的空間，Eclipse 的特色之一就是不用安裝，直接點擊 eclipse.exe 即可開始使用。</p></li><li><h3 id="_2-4-2-建立-eclipse-專案-並開發、執行-java-程式" tabindex="-1">2.4.2 建立 Eclipse 專案，並開發、執行 Java 程式 <a class="header-anchor" href="#_2-4-2-建立-eclipse-專案-並開發、執行-java-程式" aria-hidden="true">#</a></h3><ul><li><h4 id="step-01" tabindex="-1">step 01 <a class="header-anchor" href="#step-01" aria-hidden="true">#</a></h4><p>輸入 <code>工作空間 (Workspace)</code>。 顧名思義，接下來所有在 Eclipse 裡生成的專案或是程式檔案，都會放置在該路徑下。</p></li><li><h4 id="step-02" tabindex="-1">step 02 <a class="header-anchor" href="#step-02" aria-hidden="true">#</a></h4><p>首次使用會出現 <code>歡迎(Welcome)</code> 畫面，點選左上角「 X 」按鍵，關閉該畫面。</p></li><li><h4 id="step-03" tabindex="-1">step 03 <a class="header-anchor" href="#step-03" aria-hidden="true">#</a></h4><p>在左側空白的「 <code>Project Explorer</code> 」處，點選滑鼠右鍵，選擇「 <code>New</code> 」，再選擇「 <code>Java Project</code> 」，建立新專案。</p></li><li><h4 id="step-04" tabindex="-1">step 04 <a class="header-anchor" href="#step-04" aria-hidden="true">#</a></h4><p>輸入 <code>專案名稱 (Project Name)</code>，並選擇合適的 <code>JRE 版本</code>。 如：jdk 1.8.0_45</p></li><li><h4 id="step-05" tabindex="-1">step 05 <a class="header-anchor" href="#step-05" aria-hidden="true">#</a></h4><p>專案建立完成後，左側的「 <code>Project Explorer</code> 」內，將出現 <code>剛剛建立的專案名稱</code>，點選該專案，點擊滑鼠右鍵，選擇「 <code>New</code> 」，再選擇「 <code>Class</code> 」，建立新類別。</p></li><li><h4 id="step-06" tabindex="-1">step 06 <a class="header-anchor" href="#step-06" aria-hidden="true">#</a></h4><p>在彈出的「 <code>New Java Class</code> 」視窗裡，輸入 <code>類別 (class) 名稱</code>，這裡用「 HelloWorld 」，再勾選「 <code>public static void main(String[] args)</code> 」的核取方格。</p></li><li><h4 id="step-07" tabindex="-1">step 07 <a class="header-anchor" href="#step-07" aria-hidden="true">#</a></h4></li></ul></li></ul>',14),t=[l];function h(c,o,n,s,p,v){return i(),e("div",null,t)}const J=a(r,[["render",h]]);export{_ as __pageData,J as default};
